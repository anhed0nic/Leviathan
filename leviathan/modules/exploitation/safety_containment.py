"""Safety containment module for controlled exploitation execution."""

import asyncio
import os
import signal
import subprocess
import time
from typing import Dict, List, Any, Optional, Union, Callable
from pathlib import Path
from contextlib import asynccontextmanager
import psutil

from ...core.module_base import AnalysisModule
from ...utils.logging import get_logger


class SafetyContainment(AnalysisModule):
    """Provides safety mechanisms for controlled exploitation execution."""

    def __init__(self, config=None):
        super().__init__(config)
        self.logger = get_logger("leviathan.exploitation.safety")

        # Safety state
        self.active_containers = {}
        self.safety_violations = []
        self.resource_limits = {
            "cpu_percent": 50.0,
            "memory_mb": 512,
            "disk_mb": 100,
            "network_connections": 5,
            "execution_time_seconds": 300
        }

        # Update limits from config
        if config:
            self.resource_limits.update(config.get("resource_limits", {}))

    @property
    def name(self) -> str:
        return "safety_containment"

    @property
    def description(self) -> str:
        return "Provides safety mechanisms for controlled exploitation execution"

    async def analyze(self, target: Any) -> Dict[str, Any]:
        """Execute code in a safe containment environment."""
        if not isinstance(target, dict):
            raise ValueError("Target must be a containment configuration dictionary")

        execution_config = target.get("execution_config", {})
        safety_config = target.get("safety_config", {})
        code_to_execute = target.get("code", "")
        payload_data = target.get("payload", {})

        if not code_to_execute and not payload_data:
            return {
                "module": self.name,
                "success": False,
                "error": "No code or payload provided for execution"
            }

        container_id = f"container_{int(time.time() * 1000)}"

        self.logger.info(
            "Starting safe execution",
            container_id=container_id,
            has_code=bool(code_to_execute),
            has_payload=bool(payload_data)
        )

        try:
            # Create containment environment
            async with self._create_containment_environment(container_id, safety_config) as env:
                # Execute in safe environment
                result = await self._execute_in_containment(
                    env, execution_config, code_to_execute, payload_data
                )

                return {
                    "module": self.name,
                    "container_id": container_id,
                    "success": result["success"],
                    "execution_time": result.get("execution_time", 0),
                    "resource_usage": result.get("resource_usage", {}),
                    "output": result.get("output", ""),
                    "errors": result.get("errors", []),
                    "safety_violations": result.get("safety_violations", []),
                    "contained": True
                }

        except Exception as e:
            self.logger.error("Safe execution failed", container_id=container_id, error=str(e))
            return {
                "module": self.name,
                "container_id": container_id,
                "success": False,
                "error": str(e),
                "safety_violations": ["execution_failure"]
            }

    @asynccontextmanager
    async def _create_containment_environment(self, container_id: str, safety_config: Dict[str, Any]):
        """Create a safe containment environment."""
        env = {
            "container_id": container_id,
            "start_time": time.time(),
            "processes": [],
            "temp_files": [],
            "network_connections": [],
            "safety_violations": [],
            "resource_monitor": None
        }

        try:
            # Initialize containment
            await self._initialize_containment(env, safety_config)

            # Start resource monitoring
            env["resource_monitor"] = asyncio.create_task(
                self._monitor_resources(env, safety_config)
            )

            self.active_containers[container_id] = env

            yield env

        finally:
            # Cleanup containment
            await self._cleanup_containment(env)

    async def _initialize_containment(self, env: Dict[str, Any], safety_config: Dict[str, Any]) -> None:
        """Initialize the containment environment."""
        container_id = env["container_id"]

        # Create isolated working directory
        work_dir = Path(f"/tmp/leviathan_containment_{container_id}")
        work_dir.mkdir(parents=True, exist_ok=True)
        env["work_dir"] = work_dir

        # Set restrictive permissions
        os.chmod(work_dir, 0o700)

        # Create limited environment variables
        env["env_vars"] = {
            "PATH": "/usr/local/bin:/usr/bin:/bin",
            "HOME": str(work_dir),
            "TMPDIR": str(work_dir),
            "USER": "leviathan_contained",
            "LOGNAME": "leviathan_contained"
        }

        # Update with any additional env vars from config
        env["env_vars"].update(safety_config.get("environment_variables", {}))

        self.logger.debug("Containment environment initialized", container_id=container_id)

    async def _execute_in_containment(self, env: Dict[str, Any], execution_config: Dict[str, Any],
                                    code: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Execute code/payload in the containment environment."""
        start_time = time.time()
        result = {
            "success": False,
            "output": "",
            "errors": [],
            "resource_usage": {},
            "safety_violations": []
        }

        try:
            execution_type = execution_config.get("type", "subprocess")

            if execution_type == "subprocess":
                result = await self._execute_subprocess(env, execution_config, code, payload)
            elif execution_type == "python":
                result = await self._execute_python_code(env, execution_config, code, payload)
            elif execution_type == "shell":
                result = await self._execute_shell_code(env, execution_config, code, payload)
            elif execution_type == "payload_simulation":
                result = await self._simulate_payload_execution(env, execution_config, payload)
            else:
                result["errors"].append(f"Unknown execution type: {execution_type}")

            # Check for safety violations during execution
            result["safety_violations"] = env.get("safety_violations", [])

        except Exception as e:
            result["errors"].append(str(e))
            result["safety_violations"].append("execution_exception")

        finally:
            execution_time = time.time() - start_time
            result["execution_time"] = execution_time

            # Record resource usage
            result["resource_usage"] = await self._get_resource_usage(env)

        return result

    async def _execute_subprocess(self, env: Dict[str, Any], config: Dict[str, Any],
                                code: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Execute code as a subprocess with safety limits."""
        command = config.get("command", ["python3", "-c", code])
        timeout = config.get("timeout", 30)

        # Pre-execution safety checks
        if not self._validate_command_safety(command):
            return {
                "success": False,
                "errors": ["Command failed safety validation"],
                "safety_violations": ["unsafe_command"]
            }

        try:
            # Execute with resource limits
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=env["work_dir"],
                env=env["env_vars"],
                preexec_fn=self._set_process_limits if os.name != 'nt' else None
            )

            env["processes"].append(process)

            # Wait for completion with timeout
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )

                return {
                    "success": process.returncode == 0,
                    "output": stdout.decode() if stdout else "",
                    "errors": [stderr.decode()] if stderr else [],
                    "return_code": process.returncode
                }

            except asyncio.TimeoutError:
                # Kill process on timeout
                await self._kill_process_tree(process.pid)
                env["safety_violations"].append("execution_timeout")
                return {
                    "success": False,
                    "errors": ["Execution timed out"],
                    "safety_violations": ["execution_timeout"]
                }

        except Exception as e:
            return {
                "success": False,
                "errors": [str(e)],
                "safety_violations": ["execution_error"]
            }

    async def _execute_python_code(self, env: Dict[str, Any], config: Dict[str, Any],
                                 code: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Python code with safety restrictions."""
        # Add safety imports and restrictions
        safe_code = f"""
import sys
sys.path = ['{env["work_dir"]}']  # Restrict path

# Disable dangerous imports
dangerous_modules = ['os', 'subprocess', 'sys', 'importlib', 'builtins']
for mod in dangerous_modules:
    sys.modules[mod] = None

# Execute user code
{code}
"""

        # Execute in isolated environment
        return await self._execute_subprocess(
            env, {**config, "command": ["python3", "-c", safe_code]}, "", payload
        )

    async def _execute_shell_code(self, env: Dict[str, Any], config: Dict[str, Any],
                                code: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Execute shell code with restrictions."""
        # Use restricted shell
        shell_command = config.get("shell", "/bin/sh")
        restricted_args = ["-r"] if "rsh" in shell_command else []

        return await self._execute_subprocess(
            env, {**config, "command": [shell_command] + restricted_args + ["-c", code]}, "", payload
        )

    async def _simulate_payload_execution(self, env: Dict[str, Any], config: Dict[str, Any],
                                        payload: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate payload execution without actual execution."""
        payload_type = payload.get("type", "unknown")

        # Simulate based on payload type
        if payload_type == "shellcode":
            result = await self._simulate_shellcode_execution(env, payload)
        elif payload_type == "webshell":
            result = await self._simulate_webshell_execution(env, payload)
        elif payload_type == "reverse_shell":
            result = await self._simulate_reverse_shell_execution(env, payload)
        else:
            result = {
                "success": True,
                "output": f"Simulated execution of {payload_type} payload",
                "simulation": True
            }

        return result

    async def _simulate_shellcode_execution(self, env: Dict[str, Any], payload: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate shellcode execution."""
        shellcode = payload.get("raw_payload", b"")
        architecture = payload.get("architecture", "x86_64")

        # Simulate shellcode analysis without execution
        analysis = {
            "architecture": architecture,
            "size": len(shellcode) if isinstance(shellcode, (bytes, str)) else 0,
            "potential_syscalls": ["execve", "socket", "connect"],  # Simulated
            "risk_level": "high"
        }

        return {
            "success": True,
            "output": f"Shellcode analysis: {analysis}",
            "simulation": True,
            "analysis": analysis
        }

    async def _simulate_webshell_execution(self, env: Dict[str, Any], payload: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate webshell execution."""
        language = payload.get("language", "php")
        functionality = payload.get("functionality", [])

        # Simulate webshell behavior
        simulated_output = f"Web shell ({language}) would provide: {', '.join(functionality)}"

        return {
            "success": True,
            "output": simulated_output,
            "simulation": True,
            "functionality_tested": functionality
        }

    async def _simulate_reverse_shell_execution(self, env: Dict[str, Any], payload: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate reverse shell execution."""
        host = payload.get("host", "unknown")
        port = payload.get("port", 0)

        # Simulate connection attempt (without actual connection)
        simulated_output = f"Reverse shell would connect to {host}:{port}"

        # Flag as safety violation since this would be actual network activity
        env["safety_violations"].append("network_connection_attempt")

        return {
            "success": False,  # Fail simulation to prevent actual execution
            "output": simulated_output,
            "simulation": True,
            "blocked_reason": "network_connection_attempt"
        }

    async def _monitor_resources(self, env: Dict[str, Any], safety_config: Dict[str, Any]) -> None:
        """Monitor resource usage and enforce limits."""
        container_id = env["container_id"]
        check_interval = safety_config.get("monitor_interval", 1.0)

        while container_id in self.active_containers:
            try:
                # Check resource usage
                usage = await self._get_resource_usage(env)

                # Check limits
                violations = self._check_resource_limits(usage)

                if violations:
                    env["safety_violations"].extend(violations)
                    self.logger.warning(
                        "Resource limit violation",
                        container_id=container_id,
                        violations=violations
                    )

                    # Kill processes if critical violation
                    if any(v in ["cpu_limit_exceeded", "memory_limit_exceeded"] for v in violations):
                        await self._emergency_kill(env)

                await asyncio.sleep(check_interval)

            except Exception as e:
                self.logger.error("Resource monitoring failed", container_id=container_id, error=str(e))
                break

    async def _get_resource_usage(self, env: Dict[str, Any]) -> Dict[str, Any]:
        """Get current resource usage for the containment environment."""
        usage = {
            "cpu_percent": 0.0,
            "memory_mb": 0,
            "disk_mb": 0,
            "network_connections": 0,
            "process_count": len(env.get("processes", []))
        }

        # Aggregate process resource usage
        total_cpu = 0.0
        total_memory = 0

        for process in env.get("processes", []):
            if process and hasattr(process, 'pid'):
                try:
                    proc = psutil.Process(process.pid)
                    total_cpu += proc.cpu_percent()
                    total_memory += proc.memory_info().rss / (1024 * 1024)  # MB
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue

        usage["cpu_percent"] = total_cpu
        usage["memory_mb"] = total_memory

        # Check working directory size
        work_dir = env.get("work_dir")
        if work_dir and work_dir.exists():
            try:
                usage["disk_mb"] = sum(
                    f.stat().st_size for f in work_dir.rglob('*') if f.is_file()
                ) / (1024 * 1024)
            except Exception:
                pass

        return usage

    def _check_resource_limits(self, usage: Dict[str, Any]) -> List[str]:
        """Check if resource usage exceeds limits."""
        violations = []

        if usage.get("cpu_percent", 0) > self.resource_limits["cpu_percent"]:
            violations.append("cpu_limit_exceeded")

        if usage.get("memory_mb", 0) > self.resource_limits["memory_mb"]:
            violations.append("memory_limit_exceeded")

        if usage.get("disk_mb", 0) > self.resource_limits["disk_mb"]:
            violations.append("disk_limit_exceeded")

        if usage.get("network_connections", 0) > self.resource_limits["network_connections"]:
            violations.append("network_limit_exceeded")

        return violations

    async def _emergency_kill(self, env: Dict[str, Any]) -> None:
        """Emergency kill all processes in containment."""
        for process in env.get("processes", []):
            if process and hasattr(process, 'pid'):
                await self._kill_process_tree(process.pid)

        env["safety_violations"].append("emergency_kill")

    async def _kill_process_tree(self, pid: int) -> None:
        """Kill a process and all its children."""
        try:
            parent = psutil.Process(pid)
            children = parent.children(recursive=True)

            # Kill children first
            for child in children:
                try:
                    child.kill()
                except psutil.NoSuchProcess:
                    pass

            # Kill parent
            parent.kill()

        except psutil.NoSuchProcess:
            pass

    def _validate_command_safety(self, command: List[str]) -> bool:
        """Validate that a command is safe to execute."""
        if not command:
            return False

        # Dangerous commands
        dangerous_commands = [
            "rm", "rmdir", "del", "format", "fdisk", "mkfs",
            "dd", "wget", "curl", "nc", "netcat", "ncat",
            "ssh", "scp", "ftp", "telnet"
        ]

        # Check command and arguments
        for arg in command:
            if any(dangerous in arg.lower() for dangerous in dangerous_commands):
                return False

        return True

    def _set_process_limits(self) -> None:
        """Set process resource limits (Unix only)."""
        try:
            import resource

            # Set CPU time limit
            resource.setrlimit(resource.RLIMIT_CPU, (300, 300))  # 5 minutes

            # Set memory limit
            memory_limit = self.resource_limits["memory_mb"] * 1024 * 1024  # bytes
            resource.setrlimit(resource.RLIMIT_AS, (memory_limit, memory_limit))

            # Set file size limit
            disk_limit = self.resource_limits["disk_mb"] * 1024 * 1024
            resource.setrlimit(resource.RLIMIT_FSIZE, (disk_limit, disk_limit))

        except ImportError:
            # resource module not available
            pass

    async def _cleanup_containment(self, env: Dict[str, Any]) -> None:
        """Clean up the containment environment."""
        container_id = env["container_id"]

        try:
            # Kill any remaining processes
            for process in env.get("processes", []):
                if process and not process.returncode:
                    await self._kill_process_tree(process.pid)

            # Remove temporary files and directories
            work_dir = env.get("work_dir")
            if work_dir and work_dir.exists():
                import shutil
                shutil.rmtree(work_dir, ignore_errors=True)

            # Close network connections (if any)
            for conn in env.get("network_connections", []):
                try:
                    conn.close()
                except Exception:
                    pass

            # Stop resource monitoring
            if env.get("resource_monitor"):
                env["resource_monitor"].cancel()

            # Remove from active containers
            if container_id in self.active_containers:
                del self.active_containers[container_id]

            self.logger.debug("Containment cleanup completed", container_id=container_id)

        except Exception as e:
            self.logger.error("Containment cleanup failed", container_id=container_id, error=str(e))

    def get_active_containers(self) -> List[str]:
        """Get list of active container IDs."""
        return list(self.active_containers.keys())

    def get_container_status(self, container_id: str) -> Optional[Dict[str, Any]]:
        """Get status of a specific container."""
        return self.active_containers.get(container_id)

    def emergency_stop_all(self) -> int:
        """Emergency stop all active containers."""
        stopped = 0
        for container_id, env in list(self.active_containers.items()):
            asyncio.create_task(self._cleanup_containment(env))
            stopped += 1

        self.active_containers.clear()
        return stopped