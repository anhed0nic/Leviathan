"""Exploitation pipeline orchestrator for Leviathan."""

import asyncio
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
from pathlib import Path

from ...core.module_base import AnalysisModule
from ...utils.logging import get_logger
from .exploit_simulator import ExploitSimulator
from .payload_generator import PayloadGenerator


class ExploitationPipeline(AnalysisModule):
    """Orchestrates multi-stage exploitation pipelines."""

    def __init__(self, config=None):
        super().__init__(config)
        self.logger = get_logger("leviathan.exploitation.pipeline")

        # Initialize sub-modules
        self.exploit_simulator = ExploitSimulator(config)
        self.payload_generator = PayloadGenerator(config)

        # Pipeline state
        self.active_pipelines = {}
        self.pipeline_history = []

    @property
    def name(self) -> str:
        return "exploitation_pipeline"

    @property
    def description(self) -> str:
        return "Orchestrates multi-stage exploitation pipelines"

    async def analyze(self, target: Any) -> Dict[str, Any]:
        """Execute exploitation pipeline based on target configuration."""
        if not isinstance(target, dict):
            raise ValueError("Target must be a pipeline configuration dictionary")

        pipeline_config = target.get("pipeline_config", {})
        target_info = target.get("target_info", {})
        safety_config = target.get("safety_config", {})

        pipeline_id = pipeline_config.get("id", f"pipeline_{datetime.now().strftime('%Y%m%d_%H%M%S')}")

        self.logger.info(
            "Starting exploitation pipeline",
            pipeline_id=pipeline_id,
            stages=len(pipeline_config.get("stages", []))
        )

        # Initialize pipeline
        pipeline_state = {
            "id": pipeline_id,
            "status": "initializing",
            "stages": pipeline_config.get("stages", []),
            "current_stage": 0,
            "results": [],
            "errors": [],
            "start_time": datetime.now().isoformat(),
            "target_info": target_info,
            "safety_config": safety_config
        }

        self.active_pipelines[pipeline_id] = pipeline_state

        try:
            # Execute pipeline stages
            result = await self._execute_pipeline(pipeline_state)

            # Update final state
            pipeline_state["status"] = "completed" if result["success"] else "failed"
            pipeline_state["end_time"] = datetime.now().isoformat()
            pipeline_state["final_result"] = result

            # Move to history
            self.pipeline_history.append(pipeline_state)
            del self.active_pipelines[pipeline_id]

            return {
                "module": self.name,
                "pipeline_id": pipeline_id,
                "success": result["success"],
                "stages_completed": len(result.get("stage_results", [])),
                "total_stages": len(pipeline_state["stages"]),
                "execution_time": result.get("execution_time", 0),
                "vulnerabilities_exploited": result.get("vulnerabilities_exploited", 0),
                "payloads_delivered": result.get("payloads_delivered", 0),
                "warnings": result.get("warnings", [])
            }

        except Exception as e:
            self.logger.error("Pipeline execution failed", pipeline_id=pipeline_id, error=str(e))
            pipeline_state["status"] = "failed"
            pipeline_state["error"] = str(e)
            pipeline_state["end_time"] = datetime.now().isoformat()

            # Move to history
            self.pipeline_history.append(pipeline_state)
            del self.active_pipelines[pipeline_id]

            return {
                "module": self.name,
                "pipeline_id": pipeline_id,
                "success": False,
                "error": str(e),
                "stages_completed": pipeline_state["current_stage"]
            }

    async def _execute_pipeline(self, pipeline_state: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the pipeline stages."""
        stages = pipeline_state["stages"]
        results = []
        start_time = datetime.now()

        for i, stage in enumerate(stages):
            pipeline_state["current_stage"] = i

            self.logger.info(
                "Executing pipeline stage",
                pipeline_id=pipeline_state["id"],
                stage=i,
                stage_name=stage.get("name", f"stage_{i}")
            )

            try:
                # Execute stage
                stage_result = await self._execute_stage(stage, pipeline_state)

                results.append({
                    "stage": i,
                    "name": stage.get("name"),
                    "success": stage_result["success"],
                    "result": stage_result,
                    "execution_time": stage_result.get("execution_time", 0)
                })

                # Check if pipeline should continue
                if not stage_result["success"] and stage.get("required", True):
                    self.logger.warning(
                        "Required stage failed, stopping pipeline",
                        pipeline_id=pipeline_state["id"],
                        stage=i
                    )
                    break

                # Apply stage results to pipeline state for next stages
                if "state_updates" in stage_result:
                    pipeline_state.update(stage_result["state_updates"])

            except Exception as e:
                self.logger.error(
                    "Stage execution failed",
                    pipeline_id=pipeline_state["id"],
                    stage=i,
                    error=str(e)
                )

                results.append({
                    "stage": i,
                    "name": stage.get("name"),
                    "success": False,
                    "error": str(e)
                })

                if stage.get("required", True):
                    break

        execution_time = (datetime.now() - start_time).total_seconds()

        # Aggregate results
        successful_stages = sum(1 for r in results if r["success"])
        vulnerabilities_exploited = sum(
            r.get("result", {}).get("vulnerabilities_exploited", 0) for r in results
        )
        payloads_delivered = sum(
            r.get("result", {}).get("payloads_delivered", 0) for r in results
        )

        return {
            "success": successful_stages == len(stages),
            "stage_results": results,
            "execution_time": execution_time,
            "vulnerabilities_exploited": vulnerabilities_exploited,
            "payloads_delivered": payloads_delivered,
            "warnings": self._collect_warnings(results)
        }

    async def _execute_stage(self, stage: Dict[str, Any], pipeline_state: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a single pipeline stage."""
        stage_type = stage.get("type")
        stage_config = stage.get("config", {})
        start_time = datetime.now()

        # Merge pipeline state into stage config
        merged_config = {**stage_config}
        merged_config.update({
            "pipeline_state": pipeline_state,
            "previous_results": pipeline_state.get("results", [])
        })

        if stage_type == "reconnaissance":
            result = await self._execute_reconnaissance_stage(merged_config)
        elif stage_type == "vulnerability_scan":
            result = await self._execute_vulnerability_scan_stage(merged_config)
        elif stage_type == "exploit_generation":
            result = await self._execute_exploit_generation_stage(merged_config)
        elif stage_type == "payload_delivery":
            result = await self._execute_payload_delivery_stage(merged_config)
        elif stage_type == "post_exploitation":
            result = await self._execute_post_exploitation_stage(merged_config)
        elif stage_type == "cleanup":
            result = await self._execute_cleanup_stage(merged_config)
        else:
            raise ValueError(f"Unknown stage type: {stage_type}")

        execution_time = (datetime.now() - start_time).total_seconds()
        result["execution_time"] = execution_time

        return result

    async def _execute_reconnaissance_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute reconnaissance stage."""
        target_info = config.get("target_info", {})

        # Simulate reconnaissance
        recon_results = {
            "target_os": target_info.get("os", "unknown"),
            "target_services": target_info.get("services", []),
            "open_ports": target_info.get("ports", []),
            "vulnerabilities_identified": []
        }

        return {
            "success": True,
            "stage_type": "reconnaissance",
            "recon_results": recon_results,
            "state_updates": {"recon_results": recon_results}
        }

    async def _execute_vulnerability_scan_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute vulnerability scanning stage."""
        recon_results = config.get("recon_results", {})
        target_vulns = config.get("target_vulnerabilities", [])

        # Simulate vulnerability scanning
        vulnerabilities = []
        for vuln in target_vulns:
            vulnerabilities.append({
                "id": vuln.get("id"),
                "type": vuln.get("type"),
                "severity": vuln.get("severity", "medium"),
                "exploit_available": vuln.get("exploit_available", True)
            })

        return {
            "success": True,
            "stage_type": "vulnerability_scan",
            "vulnerabilities_found": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "state_updates": {"vulnerabilities": vulnerabilities}
        }

    async def _execute_exploit_generation_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute exploit generation stage."""
        vulnerabilities = config.get("vulnerabilities", [])
        generation_config = config.get("generation_config", {})

        # Generate exploits for vulnerabilities
        exploits_generated = []
        for vuln in vulnerabilities:
            if vuln.get("exploit_available", False):
                # Use exploit simulator to generate exploit
                exploit_result = await self.exploit_simulator.analyze({
                    "vulnerability": vuln,
                    "generation_config": generation_config
                })

                if exploit_result.get("exploits_generated", 0) > 0:
                    exploits_generated.extend(exploit_result.get("exploits", []))

        return {
            "success": len(exploits_generated) > 0,
            "stage_type": "exploit_generation",
            "exploits_generated": len(exploits_generated),
            "exploits": exploits_generated,
            "state_updates": {"exploits": exploits_generated}
        }

    async def _execute_payload_delivery_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute payload delivery stage."""
        exploits = config.get("exploits", [])
        delivery_config = config.get("delivery_config", {})

        # Generate and deliver payloads
        payloads_delivered = 0
        delivery_results = []

        for exploit in exploits:
            try:
                # Generate payload for this exploit
                payload_result = await self.payload_generator.analyze({
                    "payload_specs": [exploit.get("payload_spec", {})],
                    "encoding_config": delivery_config.get("encoding", {}),
                    "generation_config": delivery_config.get("generation", {})
                })

                if payload_result.get("payloads_generated", 0) > 0:
                    payloads_delivered += payload_result["payloads_generated"]
                    delivery_results.append({
                        "exploit_id": exploit.get("id"),
                        "payloads": payload_result.get("payloads", []),
                        "success": True
                    })
                else:
                    delivery_results.append({
                        "exploit_id": exploit.get("id"),
                        "success": False,
                        "error": "Payload generation failed"
                    })

            except Exception as e:
                delivery_results.append({
                    "exploit_id": exploit.get("id"),
                    "success": False,
                    "error": str(e)
                })

        return {
            "success": payloads_delivered > 0,
            "stage_type": "payload_delivery",
            "payloads_delivered": payloads_delivered,
            "delivery_results": delivery_results,
            "state_updates": {"payloads_delivered": payloads_delivered}
        }

    async def _execute_post_exploitation_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute post-exploitation stage."""
        post_exploitation_tasks = config.get("tasks", [])

        # Simulate post-exploitation activities
        tasks_completed = 0
        task_results = []

        for task in post_exploitation_tasks:
            task_type = task.get("type")

            if task_type == "privilege_escalation":
                result = await self._simulate_privilege_escalation(task)
            elif task_type == "lateral_movement":
                result = await self._simulate_lateral_movement(task)
            elif task_type == "data_exfiltration":
                result = await self._simulate_data_exfiltration(task)
            elif task_type == "persistence":
                result = await self._simulate_persistence(task)
            else:
                result = {"success": False, "error": f"Unknown task type: {task_type}"}

            task_results.append({
                "task_type": task_type,
                "success": result.get("success", False),
                "result": result
            })

            if result.get("success", False):
                tasks_completed += 1

        return {
            "success": tasks_completed > 0,
            "stage_type": "post_exploitation",
            "tasks_completed": tasks_completed,
            "total_tasks": len(post_exploitation_tasks),
            "task_results": task_results
        }

    async def _execute_cleanup_stage(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute cleanup stage."""
        cleanup_tasks = config.get("tasks", ["remove_payloads", "clear_logs", "restore_state"])

        # Simulate cleanup
        cleanup_results = []
        for task in cleanup_tasks:
            cleanup_results.append({
                "task": task,
                "success": True,
                "message": f"Cleaned up {task}"
            })

        return {
            "success": True,
            "stage_type": "cleanup",
            "cleanup_tasks_completed": len(cleanup_results),
            "cleanup_results": cleanup_results
        }

    async def _simulate_privilege_escalation(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate privilege escalation."""
        escalation_method = task.get("method", "sudo_exploit")

        # Simulate escalation attempt
        success = random.choice([True, False])  # Random for simulation

        return {
            "success": success,
            "method": escalation_method,
            "new_privileges": "root" if success else "unchanged",
            "message": f"Privilege escalation {'succeeded' if success else 'failed'}"
        }

    async def _simulate_lateral_movement(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate lateral movement."""
        target_host = task.get("target_host", "192.168.1.100")

        # Simulate movement
        success = random.choice([True, False])

        return {
            "success": success,
            "target_host": target_host,
            "method": "psexec" if success else "failed",
            "message": f"Lateral movement to {target_host} {'succeeded' if success else 'failed'}"
        }

    async def _simulate_data_exfiltration(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate data exfiltration."""
        data_type = task.get("data_type", "credentials")
        destination = task.get("destination", "attacker_server")

        # Simulate exfiltration
        success = random.choice([True, False])
        data_size = random.randint(1000, 100000) if success else 0

        return {
            "success": success,
            "data_type": data_type,
            "destination": destination,
            "data_exfiltrated": data_size,
            "message": f"Exfiltrated {data_size} bytes of {data_type}" if success else "Exfiltration failed"
        }

    async def _simulate_persistence(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate persistence establishment."""
        persistence_method = task.get("method", "cron_job")

        # Simulate persistence
        success = random.choice([True, False])

        return {
            "success": success,
            "method": persistence_method,
            "message": f"Persistence {'established' if success else 'failed'} via {persistence_method}"
        }

    def _collect_warnings(self, results: List[Dict[str, Any]]) -> List[str]:
        """Collect warnings from stage results."""
        warnings = []
        for result in results:
            if not result["success"]:
                warnings.append(f"Stage {result['stage']} ({result['name']}) failed")
            if "warnings" in result.get("result", {}):
                warnings.extend(result["result"]["warnings"])

        return warnings

    def get_pipeline_status(self, pipeline_id: str) -> Optional[Dict[str, Any]]:
        """Get status of a running pipeline."""
        if pipeline_id in self.active_pipelines:
            return self.active_pipelines[pipeline_id]
        return None

    def get_pipeline_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get pipeline execution history."""
        return self.pipeline_history[-limit:]

    def cancel_pipeline(self, pipeline_id: str) -> bool:
        """Cancel a running pipeline."""
        if pipeline_id in self.active_pipelines:
            pipeline = self.active_pipelines[pipeline_id]
            pipeline["status"] = "cancelled"
            pipeline["end_time"] = datetime.now().isoformat()
            self.pipeline_history.append(pipeline)
            del self.active_pipelines[pipeline_id]
            return True
        return False